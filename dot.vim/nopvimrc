" Note: "{{{
" <If> do not 0
" Highlight with ZenkakuSpace /ã€€/
" via Shougo's vimrc
"}}}

"---------------------------------------------------------------------------
" Initialize:"{{{
"

" Disable Vi compatible commands.
set nocompatible

" Platform detection
" Windows
let s:iswin = has('win16') || has('win32') || has('win64')
" Mac
let s:ismac = !s:iswin && has('macunix') || has('mac')

let s:tmp = &runtimepath
"set all&
let &runtimepath = s:tmp
unlet s:tmp

" Position of vim runtime "{{{
if s:iswin
  " let g:vim_dir = expand('~/vimfiles')
  let g:vim_dir = expand('~/.vim')
else
  " Define $DOTVIM is ~/.vim on *nix
  let g:vim_dir = expand('~/.vim')
endif
let g:vim_info_dir = g:vim_dir . '/initfiles'
" Make directory "{{{
if !isdirectory(g:vim_dir)
  call mkdir(g:vim_dir, 'p')
endif
if !isdirectory(g:vim_info_dir)
  call mkdir(g:vim_info_dir, 'p')
endif "}}}
"}}}

" Use English interface.
if s:iswin
  " For Windows.
  language message en
else
  " For Linux.
  language mes C
endif

if exists('&msghistlen')
  set msghistlen=9999
endif

" Use ',' instead of '\'.
" It is not mapped with respect well unless I set it before setting for plug in.
let mapleader = ','
" Use <Leader> in global plugin.
let g:mapleader = ','
" Use <LocalLeader> in filetype plugin.
let g:maplocalleader = 'm'

" Release keymappings for plug-in.
"nnoremap ;  <Nop>
"xnoremap ;  <Nop>
"nnoremap m  <Nop>
"xnoremap m  <Nop>
"nnoremap ,  <Nop>
"xnoremap ,  <Nop>

if s:iswin
  " Exchange path separator.
  set shellslash
endif

" In Windows/Linux, take in a difference of ".vim" and "$VIM/vimfiles".
if s:iswin
  "let $DOTVIM = expand('$VIM')
  let $DOTVIM =  g:vim_dir
else
  "let $DOTVIM = expand('~/.vim')
  let $DOTVIM = expand('~/.vim')
endif

" Because a value is not set in $MYGVIMRC with the console, set it.
if !exists('$MYGVIMRC')
  if s:iswin
    "let $MYGVIMRC = expand('$MY_HOME/_gvimrc')
    let $MYGVIMRC = expand('~/.gvimrc')
  else
    let $MYGVIMRC = expand('~/.gvimrc')
  endif
endif

" Setting for only first booting "{{{
if has('vim_starting')
  if s:iswin
    " Setting of path for use tools
    let mingw_pass = 'z:\MinGW'
    let msys_pass = 'z:\msys'
    let git_pass = 'z:\usr\bin\Git'
    let gow_pass = 'z:\usr\bin\gow'
    let plus_bin = '\bin'
    let $PATH = msys_pass . plus_bin . ';' . mingw_pass . plus_bin . ';' . git_pass . plus_bin . ';' . gow_pass . ';' . $PATH
    unlet gow_pass
  else
  " Set path.
  let $PATH = expand('~/ws/local/bin') . ':/usr/local/bin:' . $PATH
  endif
endif
" }}}

" Easily edit .vimrc and .gvimrc "{{{
nnoremap <silent> <Space>ev :<C-u>edit $MYVIMRC<CR>
nnoremap <silent> <Space>eg :<C-u>edit $MYGVIMRC<CR>

"nnoremap <silent> <Space>ev :<C-u>call <SID>EditRcFileWay('cui')<CR>
"nnoremap <silent> <Space>eg :<C-u>call <SID>EditRcFileWay('gui')<CR>

" Edit rcfile way
function! s:EditRcFileWay(ui) "{{{
  if a:ui =~? 'cui'
    if tabpagenr('$') <= 1 || (line('$') <= 1 && col('.') <= 1) || bufname('#') =~? '.vimrc'
      edit $MYVIMRC
    else
      tabedit $MYVIMRC
    endif
  else
    " GVIMRC
    if tabpagenr('$') <= 1 &&  (line('$') <= 1 && col('.') <= 1) || bufname('#') =~? '.gvimrc'
      edit $MYGVIMRC
    else
      tabedit $MYGVIMRC
    endif
  endif
endfunction "}}}

" Load .gvimrc after .vimrc edited at GVim.
nnoremap <silent> <Space>rv :<C-u>source $MYVIMRC \| if has('gui_running') \| source $MYGVIMRC \| endif \| echo "source $MYVIMRC"<CR>
nnoremap <silent> <Space>rg :<C-u>source $MYGVIMRC \| echo "source $MYGVIMRC"<CR>
"}}}

" Anywhere SID. "{{{
function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction

function! s:set_default(var, val)
  if !exists(a:var) || type({a:var}) != type(a:val)
    let {a:var} = a:val
  endif
endfunction " }}}

function! s:SNR(map) "{{{
    return printf("<SNR>%d_%s", s:SID(), a:map)
endfunction "}}}

filetype off
filetype plugin on
filetype indent on

" Initialize autocmd.
augroup MyAutoCmd
  autocmd!
augroup END

" Reload .vimrc and .gvimrc automatically.
augroup ReLoad "{{{
  autocmd!
  if !has('gui_running') && !(has('win32') || has('win64'))
    " At first load .vimrc
    autocmd  BufWritePost $MYVIMRC nested source $MYVIMRC | echo "source $MYVIMRC"
  else
    " Change color also reload .vimrc
    autocmd  BufWritePost $MYVIMRC nested source $MYVIMRC |
          \if has('gui_running') | source $MYGVIMRC | echo "source $MYVIMRC"
    autocmd  BufWritePost $MYGVIMRC nested if has('gui_running') | source $MYGVIMRC | echo "source $MYGVIMRC"
  endif
augroup END "}}}

" Load settings for each location."{{{

" Even Windows use "$HOME/.vim".
let &rtp = substitute(&rtp,
  \ escape($HOME, '\') . '/vimfiles', escape($HOME, '\') . '/.vim', 'g')

" Set runtimepath.
let pmps = expand('~/.vim/bundle/rtputil.vim')
if isdirectory(pmps)
  let &runtimepath = join([g:vim_dir, g:vim_dir . '/after', pmps, expand('$VIM'), expand('$VIMRUNTIME')], ',')
else
  let &runtimepath = join([g:vim_dir, g:vim_dir . '/after', expand('$VIM'), expand('$VIMRUNTIME')], ',')
endif
unlet pmps

"}}}

if filereadable(expand('~/.secret_vimrc'))
  execute 'source ' expand('~/.secret_vimrc')
endif

"}}}

"---------------------------------------------------------------------------
" Encoding:"{{{
"
" The automatic recognition of the character code.

" Setting of the encoding to use for a save and reading.
" Make it normal in UTF-8 in Unix.
set encoding=utf-8

" Setting of terminal encoding."{{{
if !has('gui_running')
  if &term == 'win32' || &term == 'win64'
    " Setting when use the non-GUI Japanese console.

    " Garbled unless set this.
    set termencoding=cp932
    " Japanese input changes itself unless set this.
    " Be careful because the automatic recognition of the character code is not possible!
    set encoding=japan
  else
    if $ENV_ACCESS ==# 'linux'
      set termencoding=euc-jp
    elseif $ENV_ACCESS ==# 'colinux'
      set termencoding=utf-8
    else  " fallback
      set termencoding=  " same as 'encoding'
    endif
  endif
elseif s:iswin
  " For system.
  set termencoding=cp932
endif
"}}}

" The automatic recognition of the character code."{{{
if !exists('did_encoding_settings') && has('iconv')
  let s:enc_euc = 'euc-jp'
  let s:enc_jis = 'iso-2022-jp'

  " Does iconv support JIS X 0213?
  if iconv("\x87\x64\x87\x6a", 'cp932', 'euc-jisx0213') ==# "\xad\xc5\xad\xcb"
    let s:enc_euc = 'euc-jisx0213,euc-jp'
    let s:enc_jis = 'iso-2022-jp-3'
  endif

  " Build encodings.
  let &fileencodings = 'ucs-bom'
  if &encoding !=# 'utf-8'
    let &fileencodings = &fileencodings . ',' . 'ucs-2le'
    let &fileencodings = &fileencodings . ',' . 'ucs-2'
  endif
  let &fileencodings = &fileencodings . ',' . s:enc_jis

  if &encoding ==# 'utf-8'
    let &fileencodings = &fileencodings . ',' . s:enc_euc
    let &fileencodings = &fileencodings . ',' . 'cp932'
  elseif &encoding =~# '^euc-\%(jp\|jisx0213\)$'
    let &encoding = s:enc_euc
    let &fileencodings = &fileencodings . ',' . 'utf-8'
    let &fileencodings = &fileencodings . ',' . 'cp932'
  else  " cp932
    let &fileencodings = &fileencodings . ',' . 'utf-8'
    let &fileencodings = &fileencodings . ',' . s:enc_euc
  endif
  let &fileencodings = &fileencodings . ',' . &encoding

  unlet s:enc_euc
  unlet s:enc_jis

  let did_encoding_settings = 1
endif
"}}}

if has('kaoriya')
  " For Kaoriya only.
  set fileencodings=guess
endif

" When do not include Japanese, use encoding for fileencoding.
function! AU_ReCheck_FENC()
  if &fileencoding =~# 'iso-2022-jp' && search("[^\x01-\x7e]", 'n') == 0
    let &fileencoding=&encoding
  endif
endfunction

autocmd MyAutoCmd BufReadPost * call AU_ReCheck_FENC()

" Default fileformat.
set fileformat=unix
" Automatic recognition of a new line cord.
set fileformats=unix,dos,mac
" A fullwidth character is displayed in vim properly.
set ambiwidth=double

" Command group opening with a specific character code again."{{{
" In particular effective when I am garbled in a terminal.
" Open in UTF-8 again.
command! -bang -bar -complete=file -nargs=? Utf8 edit<bang> ++enc=utf-8 <args>
" Open in iso-2022-jp again.
command! -bang -bar -complete=file -nargs=? Iso2022jp edit<bang> ++enc=iso-2022-jp <args>
" Open in Shift_JIS again.
command! -bang -bar -complete=file -nargs=? Cp932 edit<bang> ++enc=cp932 <args>
" Open in EUC-jp again.
command! -bang -bar -complete=file -nargs=? Euc edit<bang> ++enc=euc-jp <args>
" Open in UTF-16 again.
command! -bang -bar -complete=file -nargs=? Utf16 edit<bang> ++enc=ucs-2le <args>
" Open in UTF-16BE again.
command! -bang -bar -complete=file -nargs=? Utf16be edit<bang> ++enc=ucs-2 <args>

" Aliases.
command! -bang -bar -complete=file -nargs=? Jis  Iso2022jp<bang> <args>
command! -bang -bar -complete=file -nargs=? Sjis  Cp932<bang> <args>
command! -bang -bar -complete=file -nargs=? Unicode Utf16<bang> <args>
"}}}

" Tried to make a file note version."{{{
" Don't save it because dangerous.
command! WUtf8 setlocal fenc=utf-8
command! WIso2022jp setlocal fenc=iso-2022-jp
command! WCp932 setlocal fenc=cp932
command! WEuc setlocal fenc=euc-jp
command! WUtf16 setlocal fenc=ucs-2le
command! WUtf16be setlocal fenc=ucs-2
" Aliases.
command! WJis  WIso2022jp
command! WSjis  WCp932
command! WUnicode WUtf16
"}}}

" Handle it in nkf and open.
command! Nkf !nkf -g %

" Appoint a line feed."{{{
command! -bang -bar -complete=file -nargs=? Unix edit<bang> ++fileformat=unix <args>
command! -bang -bar -complete=file -nargs=? Mac edit<bang> ++fileformat=mac <args>
command! -bang -bar -complete=file -nargs=? Dos edit<bang> ++fileformat=dos <args>
command! -bang -complete=file -nargs=? WUnix write<bang> ++fileformat=unix <args> | edit <args>
command! -bang -complete=file -nargs=? WMac write<bang> ++fileformat=mac <args> | edit <args>
command! -bang -complete=file -nargs=? WDos write<bang> ++fileformat=dos <args> | edit <args>
"}}}"}}}

"---------------------------------------------------------------------------
" Search:"{{{
"
" Ignore the case of normal letters.
set ignorecase
" If the search pattern contains upper case characters, override ignorecase option.
set smartcase

" Enable incremental search.
set incsearch
" highlight search result.
set hlsearch

" Searches wrap around the end of the file.
set wrapscan
"}}}

"---------------------------------------------------------------------------
" Input Japanese:"{{{
"
if has('multi_byte_ime')
  " Settings of default ime condition.
  set iminsert=0 imsearch=0
  nnoremap / :<C-u>set imsearch=0<CR>/
  xnoremap / :<C-u>set imsearch=0<CR>/
  nnoremap ? :<C-u>set imsearch=0<CR>?
  xnoremap ? :<C-u>set imsearch=0<CR>?
endif

" Use ime
" set noimdisable
let &imdisable = 1

"}}}

"---------------------------------------------------------------------------
" Edit:"{{{
"

" Smart insert tab setting.
set smarttab
" Exchange tab to spaces.
set expandtab
" Substitute <Tab> with blanks.
set tabstop=2
" Spaces instead <Tab>.
set softtabstop=2
" Autoindent width.
set shiftwidth=2
" Round indent by shiftwidth.
set shiftround

" Enable modeline.
set modeline

" Use clipboard register.
set clipboard& clipboard+=unnamed

" Disable auto wrap.
autocmd MyAutoCmd FileType * set textwidth=0

" Enable backspace delete indent and newline.
set backspace=indent,eol,start

" Highlight parenthesis.
set showmatch
" Highlight when CursorMoved.
set cpoptions-=m
set matchtime=3
" Highlight <>.
set matchpairs&
set matchpairs+=<:>

" Display another buffer when current buffer isn't saved.
set hidden

" Auto reload if file is changed.
set autoread

" Ignore case on insert completion.
set infercase

" Search home directory path on cd.
" But can't complete.
set cdpath+=~

" Editing buffer position is same edit file location
"set browsedir=buffer

" Enable folding.
set foldenable
set foldmethod=marker
" Show folding level.
set foldcolumn=7

" Use vimgrep.
"set grepprg=internal
" Use grep.
set grepprg=grep\ -nH

" Exclude = from isfilename.
set isfname-==

" Keymapping timeout.
set timeout timeoutlen=3000 ttimeoutlen=100

" CursorHold time.
set updatetime=1000

" Don't create backup?
" Set of backup "{{{
" Set directory bkup. "{{{
let s:bkupdir = g:vim_info_dir . '/.bkup'
if !isdirectory(s:bkupdir)
  call mkdir(s:bkupdir, 'p')
endif
let &backupdir=s:bkupdir
unlet s:bkupdir "}}}
if v:version >= 703
  set nowritebackup
else
  set writebackup
endif
" }}}
set backup
" No backup
"set backup

" Don't create swap file
" Set swap file directory. "{{{
set directory-=.
let s:swapdir = g:vim_info_dir . '/.swap'
if !isdirectory(s:swapdir)
  call mkdir(s:swapdir, 'p')
endif
let &directory=s:swapdir
unlet s:swapdir "}}}
set noswapfile

" save and load fold settings automatically
" Reference: http://vim-users.jp/2009/10/hack84/
" Don't save options.
set viewoptions-=options
let &viewdir = g:vim_info_dir . '/view'
augroup MyAutoCmd
    autocmd BufWritePost *
    \   if expand('%') != '' && &buftype !~ 'nofile'
    \|      mkview
    \|  endif
    autocmd BufRead *
    \   if expand('%') != '' && &buftype !~ 'nofile'
    \|      silent loadview
    \|  endif
augroup END

" Session
set sessionoptions=buffers,curdir,folds,tabpages
let s:session_dir = g:vim_info_dir . '/.session'
" Make directory "{{{
if !isdirectory(s:session_dir)
  call mkdir(s:session_dir, 'p')
endif "}}}
let s:session_file = s:session_dir . '/session.vim'
function! s:save_session() "{{{
  let cwd = getcwd()
  " echomsg "cwd : " . cwd
  " echomsg "s:session_dir : " . s:session_dir
  " echomsg "s:session_file : " . s:session_file
  try
    cd `=s:session_dir`
  catch /E121/
    echo "Failed cd ."
  catch /E15/
    echo "Failed cd ."
  endtry
  try
    mksession! `=s:session_file`
    echo "Session saved."
  catch /E121/
    echo "Failed session saved."
  catch /E15/
    echo "Failed session saved."
  finally
    cd `=cwd`
  endtry
endfunction "}}}
function! s:load_session() "{{{
    let neco_enabled = exists(':NeoComplCacheDisable')
    if neco_enabled
        NeoComplCacheDisable
    endif
    if filereadable(s:session_file)
        let cwd = getcwd()
        cd ~
        source `=s:session_file`
        cd `=cwd`
    endif
    tabdo CD
    if neco_enabled
        NeoComplCacheEnable
    endif
endfunction "}}}
nnoremap <silent> [Space]Se :<C-u>call <SID>load_session()<CR>
nnoremap <silent> [Space]se :<C-u>call <SID>save_session()<CR>

" Undo
if has('persistent_undo')
  " Set undofile. "{{{
  set undofile
  "let &undodir=&directory
  let s:undorectory = g:vim_info_dir . '/.undo'
  if !isdirectory(s:undorectory)
    call mkdir(s:undorectory, 'p')
  endif
  let &undodir=s:undorectory
  unlet s:undorectory "}}}
endif

" Set tags file.
if has('path_extra')
" Don't search tags file in current directory. And search upward.
set tags& tags-=tags tags+=./tags;
endif
set notagbsearch

" Enable virtualedit in all mode "{{{
if has('virtualedit')
  set virtualedit=all
  if has('virtualedit') && &virtualedit =~# '\<all\>'
    nnoremap <expr> <SID>($-if-right-of-$)  (col('.') >= col('$') ? '$' : '')
    nnoremap        <SID>(noremap-p)        p
    nmap p <SID>($-if-right-of-$)<SID>(noremap-p)
  endif
endif " }}}

" Set keyword help.
set keywordprg=:help

" Binary whith xxd
augroup Binary "{{{
  autocmd!
  autocmd BufReadPre  *.bin let &bin=1
  autocmd BufReadPost *.bin if &bin | %!xxd
  autocmd BufReadPost *.bin set ft=xxd | endif
  autocmd BufWritePre *.bin if &bin | %!xxd -r
  autocmd BufWritePre *.bin endif
  autocmd BufWritePost *.bin if &bin | %!xxd
  autocmd BufWritePost *.bin set nomod | endif
augroup END "}}}

"}}}

"---------------------------------------------------------------------------
" View:"{{{
"

" Antialias
if has('mac')
  set antialias
endif

augroup vimrc-auto-cursorline "{{{
  autocmd!
  autocmd CursorMoved,CursorMovedI * call s:auto_cursorline('CursorMoved')
  autocmd CursorHold,CursorHoldI * call s:auto_cursorline('CursorHold')
  autocmd WinEnter * call s:auto_cursorline('WinEnter')
  autocmd WinLeave * call s:auto_cursorline('WinLeave')

  let s:cursorline_lock = 0
  function! s:auto_cursorline(event)
    if a:event ==# 'WinEnter'
      setlocal cursorline
      let s:cursorline_lock = 2
    elseif a:event ==# 'WinLeave'
      setlocal nocursorline
    elseif a:event ==# 'CursorMoved'
      if s:cursorline_lock
        if 1 < s:cursorline_lock
          let s:cursorline_lock = 1
        else
          setlocal nocursorline
          let s:cursorline_lock = 0
        endif
      endif
    elseif a:event ==# 'CursorHold'
      setlocal cursorline
      let s:cursorline_lock = 1
    endif
  endfunction
augroup END "}}}

" Show cursorline "{{{
if v:version > 700
  " Drow cursorline only curent window
  augroup MyAutoCmd
    autocmd!
    autocmd WinLeave * setlocal nocursorline
    " Don't show cursorline that filetype is vimshell ...
    autocmd WinEnter,BufRead * if !((&ft =~? "vimshell") || (&ft =~? "int-*") || (&ft =~? "term-*") || (&ft =~? "vimfiler")) | setlocal cursorline
  augroup END
endif " }}}

" Show line number.
set number
" set relativenumber
" Show space for line number
set numberwidth=10
" Show special key
set list
"set listchars=eol:.,tab:>-,trail:],extends:>,precedes:<
" Show <TAB>, lastspace
set listchars=tab:>-,trail:_
" Wrap long line.
set wrap
" Wrap conditions.
set whichwrap+=h,l,<,>,[,],b,s,~
" Show ruler
set ruler
"set rulerformat=%15(%c%V\ %p%%%)
" Always display statusline.
set laststatus=2
" Height of command line.
set cmdheight=2
" Show command on statusline.
set showcmd
"diff Settings
set diffopt=vertical

" Show toole.
set title
" Title length.
set titlelen=999
" Title string.
" Next function is invilid, why?
function! s:my_titlestring() "{{{
  let l:titlestr = ''
  let l:titlestr .= "%{expand('%:p:.')} "
  let l:titlestr .= "%(%m%r%w%) "
  let l:titlestr .= "%<\(%{SnipMid(getcwd(),80-len(expand('%:p:.')),'...')}\) "
  let l:titlestr .= "\[%n\]"
  return l:titlestr
endfunction "}}}
let &titlestring = '%!' . s:SID_PREFIX() . 'my_titlestring()'
let &titlestring="%{expand('%:p:.')}%(%m%r%w%) %<\(%{SnipMid(getcwd(),80-len(expand('%:p:.')),'...')}\) \[%n\]"

" Set tabline.
function! s:my_tabline() "{{{
  let l:s = ''

  for l:i in range(1, tabpagenr('$'))
    let l:bufnrs = tabpagebuflist(i)
    let l:curbufnr = l:bufnrs[tabpagewinnr(l:i) - 1]  " first window, first appears

    "let l:no = (l:i <= 10 ? l:i-1 : '#')  " display 0-origin tabpagenr.
    let l:no = (l:i <= 10 ? l:i : '#')  " display tabpagenr.
    let l:mod = getbufvar(bufnr("%"), "&modified") ? '!' : ' '
    let l:title = gettabwinvar(l:i, tabpagewinnr(l:i), 'title')
    if l:title == ''
      let l:title = fnamemodify(gettabwinvar(l:i, tabpagewinnr(l:i), 'cwd'), ':t')
      if l:title == ''
        let l:title = fnamemodify(bufname(l:curbufnr),':t')
        if l:title == ''
          let l:title = '[No Name]'
        endif
      endif
    endif

    let l:s .= '%'.l:i.'T'
    let l:s .= '%#' . (l:i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
    let l:s .= ' ' . l:no . ':' . l:title . l:mod
    let l:s .= '%#TabLineFill#'
    let l:s .= ' | '
  endfor

  " let l:s .= '%#TabLineFill#%T%=%#TabLine#|%999X %X'
    let l:s .= '%#TabLineFill#%T%=%#TabLine#[%999X %{fnamemodify(getcwd(), ":~")} ]'
  "endif
  return l:s
endfunction "}}}
let &tabline = '%!' . s:SID_PREFIX() . 'my_tabline()'
" Always show tab
set showtabline=2

" Set statusline. "{{{

"let &statusline="[%n] \%{winnr('$')>1?'['.winnr().'/'.winnr('$').(winnr('#')==winnr()?'#':'').']':''}\ %{expand('%:p:.')}\ %m%r%h\ %<\(%{SnipMid(getcwd(),80-len(expand('%:p:.')),'...')}\)\ %=%{'['.(&fenc!=''?&fenc:&enc)}:%{&ff}%{(&ft!=''?':'.&ft:'').']'}\ %<\<%05l\/%05L\>"

function! s:makestatusline() "{{{
  " mode
  let l:sts = "[%{mode()}] "
  " let l:sts .= "[%n] %{winnr('$')>1 ? '[' . winnr() . '/' . winnr('$') . (winnr('#') == winnr() ? '#':'').']':''} "
  let l:sts .= "%{winnr('$')>1 ? '[' . winnr() . '/' . winnr('$') . (winnr('#') == winnr() ? '#':'').']':''} "
  let l:sts .= "%{expand('%:p:.')} %m%r%h %<(%{SnipMid(getcwd(), 80-len(expand('%:p:.')), '..')}) "

  let l:sts .= "%="
  let l:sts .= "%("
  if exists('g:loaded_eskk')    " eskk.vim
    "let l:sts .= ' %{eskk#statusline("IM:%s", "IM:off")}'
    " Too hevey
    let l:sts .= ' %{eskk#statusline()}'
  elseif exists('g:skk_loaded')    " skk.vim
    let l:sts .= ' %{SkkGetModeStr()}'
  endif
  let l:sts .= "%)"
  let l:sts .= "%{'['.(&fenc!=''?&fenc:&enc)}:%{&ff}%{(&ft!='' ? ':'.&ft : '').']'}\ %(%<\<%05l\/%05L\>%)"
 return l:sts
endfunction "}}}
let &statusline = '%!' . s:SID_PREFIX() . 'makestatusline()'
" }}}

" Set folded line
"setlocal foldtext=getline(v:foldstart+1)

" Turn down a long line appointed in 'breakat'
" Set linebreak
set linebreak
if s:iswin || !has('gui_running')
  " let &showbreak='-->'
  let &showbreak='>\'
else
  let &showbreak='>\'
endif
set breakat=\ \	;:,!?

" Do not display greetings message at the time of Vim start.
set shortmess=aTI

" sound on errors
set noerrorbells

" Disable bell.
set visualbell t_bv=

" Display candidate supplement.
set wildmenu
set wildmode=list:longest,full
" Increase history amount.
set history=200
" Display all the information of the tag by the supplement of the Insert mode.
set showfulltag
" Can supplement a tag in a command-line.
set wildoptions=tagfile

" Enable spell check.
set spelllang=en_us

" Completion setting.
set completeopt=menuone,preview
" Don't complete from other buffer.
set complete=.
"set complete=.,w,b,i,t
" Set popup menu max height.
set pumheight=20

" Report changes.
set report=0

" Maintain a current line at the time of movement as much as possible.
set nostartofline

" Splitting a window will put the new window below the current one.
set splitbelow
" Splitting a window will put the new window right the current one.
set splitright
" Set minimal width for current window.
set winwidth=60
" Set minimal height for current window.
set winheight=20
" Set maximam maximam command line window.
set cmdwinheight=5
" No equal window size.
set noequalalways

" Adjust window size of preview and help.
set previewheight=3
set helpheight=12

" Don't redraw while macro executing.
set lazyredraw

" When a line is long, do not omit it in @.
set display=lastline
" Display an invisible letter with hex format.
set display+=uhex

" Disable automatically insert comment.
autocmd MyAutoCmd FileType * setl formatoptions-=ro | setl formatoptions+=mM
" Enable multibyte format.
set formatoptions+=mM

" Scroll Off
"set scrolloff=0
let g:scrolloff = 5    " see below

" Hack for <LeftMouse> not to adjust ('scrolloff') when single-clicking.
" Implement 'scrolloff' by auto-command to control the fire.
autocmd MyAutoCmd CursorMoved * call s:reinventing_scrolloff()
let s:last_lnum = -1
function! s:reinventing_scrolloff() "{{{
    if g:scrolloff ==# 0 || s:last_lnum > 0 && line('.') ==# s:last_lnum
        return
    endif
    let s:last_lnum = line('.')
    let winline     = winline()
    let winheight   = winheight(0)
    let middle      = winheight / 2
    let upside      = (winheight / winline) >= 2
    " If upside is true, add winlines to above the cursor.
    " If upside is false, add winlines to under the cursor.
    if upside
        let up_num = g:scrolloff - winline + 1
        let up_num = winline + up_num > middle ? middle - winline : up_num
        if up_num > 0
            execute 'normal!' up_num."\<C-y>"
        endif
    else
        let down_num = g:scrolloff - (winheight - winline)
        let down_num = winline - down_num < middle ? winline - middle : down_num
        if down_num > 0
            execute 'normal!' down_num."\<C-e>"
        endif
    endif
endfunction "}}}

" Todo: Setting for way of window split (filetype,bufname)

"}}}

"---------------------------------------------------------------------------
" Syntax:"{{{
"

" Enable syntax color.
syntax enable

" Enable smart indent.
set autoindent smartindent

augroup MyAutoCmd "{{{

  " Because textwidth is auto setted 78, in ftplugin of vim
  " This line Position is under next sentence, that 'ftplugin on' and 'ftpindent on'
  autocmd FileType vim setl textwidth=0

  " Easily load VimScript.
  autocmd FileType vim nnoremap <silent><buffer> [Space]so :write \| source % \| echo "source " . bufname('%')<CR>

  " Auto reload VimScript.
  autocmd BufWritePost,FileWritePost *.vim if &autoread | source <afile> | echo "source " . bufname('%') | endif

  " Manage long Rakefile easily
  autocmd BufNewfile,BufRead Rakefile foldmethod=syntax foldnestmax=1

  " Close help and git window by pressing q.
  autocmd FileType help,git-status,git-log,qf,gitcommit,quickrun,qfreplace,ref,simpletap-summary,ucw-history nnoremap <buffer><silent> q :<C-u>close<CR>
  autocmd FileType * if &readonly | nnoremap <buffer><silent> q :<C-u>close<CR> | endif
  " Add bufname is Highlight test and filetype is te*xt
  " Finding to better way
  autocmd BufNewFile,BufRead * if ((bufname('%') =~? 'Highlight test') || (&ft =~? 'te*xt')) | nnoremap <silent><buffer> q :<C-u>close<CR>| endif

  " Close help and git window by pressing q.
  autocmd FileType ref nnoremap <buffer> <TAB> <C-w>w

  "autocmd FileType c setlocal ts=4 sw=4 sts=4 foldmethod=syntax
  autocmd FileType c setlocal ts=4 sw=4 sts=4

  " Enable omni completion."{{{
  autocmd FileType ada setlocal omnifunc=adacomplete#Complete
  autocmd FileType c setlocal omnifunc=ccomplete#Complete
  autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
  autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  "autocmd FileType java setlocal omnifunc=javacomplete#Complete
  autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd FileType php setlocal omnifunc=phpcomplete#CompletePHP
  autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
  "autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
  "autocmd FileType sql setlocal omnifunc=sqlcomplete#Complete
  autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
  "autocmd FileType * if &l:omnifunc == '' | setlocal omnifunc=syntaxcomplete#Complete | endif
  "}}}

  " Set file type addme "{{{
  " If you open txt file
  autocmd BufReadPost,BufNewFile *.txt call s:structured_text()
  function! s:structured_text() "{{{
    let line1 = getline(1)
    let line2 = getline(2)
    execute 'setfiletype'
          \ line1 =~ '^\([=-`:''"~^_*+#<>]\)\1*$' ? 'rst' :
          \ line1 =~ '^*'      ? 'hatena'   :
          \ line1 =~ '^#' ||
          \ line2 =~ '^=\+$'   ? 'markdown' :
          \                      'text'
  endfunction "}}}
  " If you open lisp file
  " autocmd BufNewFile,BufRead *.l,*.xyzzy,.emacs setlocal filetype=lisp
  autocmd BufNewFile,BufRead *.xyzzy,.emacs setlocal filetype=lisp
  " If you open vb file
  autocmd BufNewFile,BufRead *.vb setlocal filetype=vb
  " }}}

augroup END " }}}

augroup vimrc-misc  " "{{{
  " Update filetype.
  autocmd BufWritePost * if &l:filetype == '' || exists('b:ftdetect')
        \ | unlet! b:ftdetect | filetype detect | endif

  " Jump to the last editing position.
  autocmd BufReadPost * if line("'\"") && line("'\"") <= line('$')
  \ | execute 'normal! g`"' | endif

  " Set 'dictionary'.
  autocmd FileType * if filereadable(expand('~/.vim/dict/' . &l:ft . '.dict'))
  \ | let &l:dict='~/.vim/dict/' . &l:ft . '.dict' | endif

  autocmd FileType * if &l:buftype !=# 'help' && &l:kp == '' &&
  \ mapcheck('K', 'n') == ''
  \ | silent! execute 'nnoremap <buffer> <unique> K <C-w>}' | endif

  " Auto open/close Quickfix/location window.
  autocmd QuickFixCmdPost [^l]* cwindow | redraw!
  autocmd QuickFixCmdPost l* lwindow | redraw!

  autocmd BufWritePost * if &l:filetype == '' || exists('b:ftdetect')
  \                      | unlet! b:ftdetect | filetype detect | endif

  autocmd BufReadPost bzr_log.* let &l:fileencoding = &termencoding
  " Edit something to avoid the confirmation when aborting.
  autocmd BufReadPost bzr_log.* 1 delete _ | silent write

augroup END  " }}}

" Syntax highlight "{{{
augroup vimrc-highlight
  autocmd!
  " Special Characters
  autocmd ColorScheme * call s:highlight_additional()
  autocmd VimEnter,WinEnter * call s:syntax_additional()
  " Misc
  autocmd ColorScheme * call s:syntax_misc()
augroup END

function! s:syntax_additional() "{{{
  let preset = exists('w:syntax_additional')
  if &l:list
    if !preset
      let w:syntax_additional = matchadd('ZenkakuSpace', 'ã€€')
    endif
  elseif preset
    call matchdelete(w:syntax_additional)
    unlet w:syntax_additional
  endif
endfunction "}}}
function! s:highlight_additional() "{{{
  " Highlight "ZenkakuSpace".
  highlight ZenkakuSpace term=underline ctermbg=9 gui=NONE guifg=#cfcfcf guibg=#4f304f
  " Change the cursor color when IME is on.
  highlight CursorIM  gui=NONE guifg=#000000 guibg=#7f0f2f
  let env = has('gui_running') ? 'gui' : 'cterm'
  " for hi in ['TabLine', 'TabLineSel']
  "   let bg = synIDattr(synIDtrans(hlID(hi)), 'bg', env)
  "   let bg = bg != '-1' ? env . 'bg=' . bg : ''
  "   "echo bg
  "   execute 'highlight ' . hi . 'Number ' . env . 'fg=DarkMagenta ' . bg
  " endfor
endfunction "}}}

function! s:syntax_misc() "{{{
  if bufname('%') =~? 'Highlight test'
    setlocal nolist
  endif
endfunction "}}}

"}}}

" html
let g:html_dynamic_folds = 1

" c
let c_no_comment_fold = 1

" Java
let g:java_highlight_functions = 'style'
let g:java_highlight_all = 1
let g:java_allow_cpp_keywords = 1

"Perl
let perl_fold = 1
let perl_fold_blocks = 1

" PHP
let g:php_folding = 1
let g:php_sql_query = 1
let php_htmlInStrings = 1

" Python
let g:python_highlight_all = 1

" XML
let g:xml_syntax_folding = 1

" Vim
let g:vimsyntax_noerror = 1
let g:vim_indent_cont = 0

" Lisp
let g:lisp_rainbow = 1

"}}}

"---------------------------------------------------------------------------
"Key-mappings: "{{{
"

" Too lazy to press Shift Key
" noremap ; :
" noremap : ;

" Movement command line mode
nnoremap <C-J> :

" Quick save and quit. "{{{
nnoremap <silent> [Space]w  :<C-u>update<CR>
nnoremap <silent> [Space]fw :<C-u>write!<CR>
" nnoremap <silent> [Space]q  :<C-u>quit<CR>
nnoremap <silent> [Space]q  :<C-u>close<CR>
nnoremap <silent> [Space]<leader>q  :<C-u>quit!<CR>
nnoremap <silent> [Space]aq :<C-u>quitall<CR>
" nnoremap <silent> [Space]fq :<C-u>quitall!<CR>
nnoremap <silent> [Space]fq :<C-u>close!<CR>
"}}}

" Easy escape."{{{
inoremap jj           <ESC>
onoremap jj           <ESC>
cnoremap jj           <C-c>
inoremap j<Space>     j
onoremap j<Space>     j
cnoremap j<Space>     j
"}}}

" <CTRL> + j = Esc "{{{
"inoremap <C-j> <Esc>
" <CTRL> + [ = Esc
"}}}

" Movement on line "{{{
noremap j gj
noremap k gk
noremap gj j
noremap gk k
"}}}

" Search selected area.
vnoremap <silent> z/ <ESC>/\v%V
vnoremap <silent> z? <ESC>?\v%V

" Clear highlight
nnoremap <silent> <ESC><ESC> :nohlsearch<CR>

" Highlight test
 nnoremap <silent> <Space>eh :<C-u>aboveleft source $VIMRUNTIME/syntax/hitest.vim<CR>

" Edit setting of vimperator "{{{
if s:iswin
  nnoremap <silent><Space>ef :<C-u>edit $HOME/.vimperatorrc<CR>
  nnoremap <silent><Space>ep :<C-u>edit $HOME/.pentadactylrc<CR>
else
  nnoremap <silent><Space>ef :<C-u>edit $HOME/.vimperatorrc<CR>
  nnoremap <silent><Space>ep :<C-u>edit $HOME/.pentadactylrc<CR>
endif " }}}

" Command-line mode keymappings:"{{{
" <C-a>, A: move to head.
cnoremap <C-a>          <Home>
"" <C-b>: previous char.
cnoremap <C-b>          <Left>
" <C-d>: delete char.
cnoremap <C-d>          <Del>
" <C-e>, E: move to end.
cnoremap <C-e>          <End>
" <C-f>: next char.
cnoremap <C-f>          <Right>
" <C-n>: next history.
cnoremap <C-n>          <Down>
" <C-p>: previous history.
cnoremap <C-p>          <Up>
" <C-k>, K: delete to end.
cnoremap <C-k> <C-\>e getcmdpos() == 1 ? '' : getcmdline()[:getcmdpos()-2]<CR>
" <C-y>: paste.
cnoremap <C-y>          <C-r>*
" <C-s>: view history.
cnoremap <C-s>          <C-f>
" <C-l>: view completion list.
cnoremap <C-l>          <C-d>
" <A-b>, W: move to previous word.
cnoremap <A-b>          <S-Left>
" <A-f>, B: move to next word.
cnoremap <A-f>          <S-Right>
cnoremap <S-TAB>        <C-p>
" <C-g>: decide candidate.
cnoremap <C-g>          <Space><C-h>
" <C-t>: insert space.
cnoremap <C-t>          <Space>
"}}}

" Auto escape / and ? in search command.
cnoremap <expr> / getcmdtype() == '/' ? '\.' : '/'

" Command line window. "{{{
nnoremap <sid>(command-line-enter) q:
xnoremap <sid>(command-line-enter) q:
nnoremap <sid>(command-line-norange) q:<C-u>

"noremap : q:i
"xnoremap : q:i

nmap :  <sid>(command-line-enter)
xmap :  <sid>(command-line-enter)
"
autocmd MyAutoCmd CmdwinEnter * call s:init_cmdwin()
function! s:init_cmdwin()  "{{{
  nnoremap <buffer> q :<C-u>quit<CR>
  nnoremap <buffer> <TAB> :<C-u>quit<CR>
  nnoremap <buffer> ; :
  xnoremap <buffer> ; :

  startinsert!
endfunction "}}}
" }}}

" [Space]: Other useful commands "{{{
" Smart space mapping.
" Notice: when starting other <Space> mappings in noremap, disappeared [Space].
nnoremap  [Space]   <Nop>
xnoremap  [Space]   <Nop>
nmap  <Space>   [Space]
xmap  <Space>   [Space]

" Echo syntax name.
nnoremap [Space]sy  :<C-u>echo synIDattr(synID(line('.'), col('.'), 1), "name")<CR>

" Quickfix "{{{

" nnoremap Q q
nmap q [Quickfix]
nnoremap [Quickfix] <Nop>

" For quickfix list  "{{{3
nnoremap <silent> [Quickfix]n  :<C-u>cnext<CR>
nnoremap <silent> [Quickfix]p  :<C-u>cprevious<CR>
nnoremap <silent> [Quickfix]r  :<C-u>crewind<CR>
nnoremap <silent> [Quickfix]N  :<C-u>cfirst<CR>
nnoremap <silent> [Quickfix]P  :<C-u>clast<CR>
nnoremap <silent> [Quickfix]fn :<C-u>cnfile<CR>
nnoremap <silent> [Quickfix]fp :<C-u>cpfile<CR>
nnoremap <silent> [Quickfix]l  :<C-u>clist<CR>
nnoremap <silent> [Quickfix]q  :<C-u>cc<CR>
nnoremap <silent> [Quickfix]o  :<C-u>copen<CR>
nnoremap <silent> [Quickfix]c  :<C-u>cclose<CR>
nnoremap <silent> [Quickfix]en :<C-u>cnewer<CR>
nnoremap <silent> [Quickfix]ep :<C-u>colder<CR>
nnoremap <silent> [Quickfix]m  :<C-u>make<CR>
nnoremap [Quickfix]M  :<C-u>make<Space>
nnoremap [Quickfix]g  :<C-u>grep<Space>
" Toggle quickfix window.
nnoremap <silent> [Quickfix]<Space> :<C-u>call <SID>toggle_quickfix_window()<CR>
function! s:toggle_quickfix_window()
  let _ = winnr('$')
  cclose
  if _ == winnr('$')
    copen
    setlocal nowrap
    setlocal whichwrap=b,s
  endif
endfunction

" For location list (mnemonic: Quickfix list for the current Window)  "{{{3
nnoremap <silent> [Quickfix]wn  :<C-u>lnext<CR>
nnoremap <silent> [Quickfix]wp  :<C-u>lprevious<CR>
nnoremap <silent> [Quickfix]wr  :<C-u>lrewind<CR>
nnoremap <silent> [Quickfix]wP  :<C-u>lfirst<CR>
nnoremap <silent> [Quickfix]wN  :<C-u>llast<CR>
nnoremap <silent> [Quickfix]wfn :<C-u>lnfile<CR>
nnoremap <silent> [Quickfix]wfp :<C-u>lpfile<CR>
nnoremap <silent> [Quickfix]wl  :<C-u>llist<CR>
nnoremap <silent> [Quickfix]wq  :<C-u>ll<CR>
nnoremap <silent> [Quickfix]wo  :<C-u>lopen<CR>
nnoremap <silent> [Quickfix]wc  :<C-u>lclose<CR>
nnoremap <silent> [Quickfix]wep :<C-u>lolder<CR>
nnoremap <silent> [Quickfix]wen :<C-u>lnewer<CR>
nnoremap <silent> [Quickfix]wm  :<C-u>lmake<CR>
nnoremap [Quickfix]wM  :<C-u>lmake<Space>
nnoremap [Quickfix]w<Space>  :<C-u>lmake<Space>
nnoremap [Quickfix]wg  :<C-u>lgrep<Space>
"}}}

"}}}

" Change current directory.
nnoremap <silent> [Space]cd :<C-u>CD %:h<CR>

" s: Windows and buffers(High priority) "{{{
" The prefix key.
nnoremap    [Window]   <Nop>
nmap    s [Window]
nnoremap C         s
xnoremap C         s
nnoremap <silent> [Window]p  :<C-u>call <SID>split_nicely()<CR>
nnoremap <silent> [Window]v  :<C-u>vsplit<CR>
nnoremap <silent> [Window]c  :<C-u>close<CR>
"nnoremap <silent> -  :<C-u>close<CR>
nnoremap <silent> [Window]o  :<C-u>only<CR>
"nnoremap <silent> [Window]w  <C-w>w

"" A .vimrc snippet that allows you to move around windows beyond tabs
nnoremap <silent> <Tab> :call <SID>NextWindowOrTab()<CR>
nnoremap <silent> <S-Tab> :call <SID>PreviousWindowOrTab()<CR>
nnoremap <silent> [Space]<Space> <C-w>p

function! s:NextWindowOrTab()
  if tabpagenr('$') == 1 && winnr('$') == 1
    call s:split_nicely()
  elseif winnr() < winnr("$")
    wincmd w
  else
    tabnext
    1wincmd w
  endif
endfunction

function! s:PreviousWindowOrTab()
  if winnr() > 1
    wincmd W
  else
    tabprevious
    execute winnr("$") . "wincmd w"
  endif
endfunction

nnoremap <silent> [Window]<Space>  :<C-u>call <SID>ToggleSplit()<CR>
function! s:MovePreviousWindow() " "{{{
  let l:prev_name = winnr()
  silent! wincmd p
  if l:prev_name == winnr()
    silent! wincmd w
  endif
endfunction " }}}
" If window isn't splited, split buffer. "{{{
function! s:ToggleSplit()
  let l:prev_name = winnr()
  silent! wincmd w
  if l:prev_name == winnr()
    split
  else
    close
  endif
endfunction " }}}
" Split nicely."{{{
"command! SplitNicely call s:split_nicely()
function! s:split_nicely()
  " Split nicely.
  if winwidth(0) > 2 * &winwidth
    vsplit
  else
    split
  endif
  wincmd p
endfunction
"}}}
" Delete current buffer."{{{
nnoremap <silent> [Window]d  :<C-u>call <SID>CustomBufferDelete(0)<CR>
nnoremap <silent> _  :<C-u>call <SID>CustomBufferDelete(0)<CR>
function! s:CustomBufferDelete(is_force)
  let current = bufnr('%')

  call s:CustomAlternateBuffer()

  if a:is_force
    silent! execute 'bdelete! ' . current
  else
    silent! execute 'bdelete ' . current
  endif
endfunction
"}}}
" Delete input buffer."{{{
nnoremap <silent> [Window]D  :<C-u>call <SID>InputBufferDelete(0)<CR>
function! s:InputBufferDelete(is_force)
  call s:ViewBufferList()

  " Create list.
  let [l:cnt, l:pos, l:list] = [0, 1, {}]
  while l:pos <= bufnr('$')
    if buflisted(l:pos)
      let l:list[l:cnt] = l:pos
      let l:cnt += 1
    endif
    let l:pos += 1
  endwhile

  let l:input = input('Select delete buffer: ', '')
  if l:input == ''
    " Cancel.
    return
  endif

  for l:in in split(l:input)
    if !has_key(l:list, l:in) || !bufexists(l:list[l:in])
      echo "\nDon't exists buffer " . l:in
      continue
    endif

    if l:in == bufnr('%') || l:in == bufname('%')
      call s:CustomAlternateBuffer()
    endif

    echo bufnr(l:list[l:in])
    if a:is_force
      silent! execute 'bdelete! ' . l:list[l:in]
    else
      silent! execute 'bdelete ' . l:list[l:in]
    endif
  endfor
endfunction
"}}}
" Force delete current buffer.
nnoremap <silent> [Window]fq  :<C-u>call <SID>CustomBufferDelete(1)<CR>
nnoremap <silent> [Window]fQ  :<C-u>call <SID>InputBufferDelete(1)<CR>
" Delete current buffer and close current window.
nnoremap <silent> [Window]d  :<C-u>call <SID>CustomBufferDelete(0)<CR>:if winnr() != 1 <Bar> close<CR>:endif<CR>
nnoremap <silent> [Window]fd  :<C-u>call <SID>CustomBufferDelete(1)<CR>:<C-u>close<CR>
" Buffer move.
" Fast buffer switch."{{{
function! s:CustomAlternateBuffer()
  if bufnr('%') != bufnr('#') && buflisted(bufnr('#'))
    buffer #
  else
    let l:cnt = 0
    let l:pos = 1
    let l:current = 0
    while l:pos <= bufnr('$')
      if buflisted(l:pos)
        if l:pos == bufnr('%')
          let l:current = l:cnt
        endif

        let l:cnt += 1
      endif

      let l:pos += 1
    endwhile

    if l:current > l:cnt / 2
      bprevious
    else
      bnext
    endif
  endif
endfunction
"}}}
"nnoremap <silent> [Window]q  :<C-u>call <SID>CustomBufferDelete(0)<CR>
" Edit"{{{
nnoremap [Window]b  :<C-u>edit<Space>
nnoremap <silent> [Window]en  :<C-u>new<CR>
nnoremap <silent> [Window]ee  :<C-u>JunkFile<CR>
nnoremap [Window]r  :<C-u>REdit<Space>
"}}}

" Scroll other window.
nnoremap <silent> <C-y> :<C-u>call <SID>ScrollOtherWindow(1)<CR>
inoremap <silent> <A-y> <C-o>:<C-u>call <SID>ScrollOtherWindow(1)<CR>
nnoremap <silent> <C-u> :<C-u>call <SID>ScrollOtherWindow(0)<CR>
inoremap <silent> <A-u> <C-o>:<C-u>call <SID>ScrollOtherWindow(0)<CR>

function! s:ScrollOtherWindow(direction)
  execute 'wincmd' (winnr('#') == 0 ? 'w' : 'p')
  execute (a:direction ? "normal! \<C-d>" : "normal! \<C-u>")
  wincmd p
endfunction
"}}}

" <C-t>: Tab pages"{{{
"
" The prefix key.
nnoremap [Tabbed]   <Nop>
nmap <C-t> [Tabbed]

" Create tab page.
nnoremap <silent> [Tabbed]c  :<C-u>tabnew<CR>
nnoremap <silent> [Tabbed]d  :<C-u>tabclose<CR>
nnoremap <silent> [Tabbed]o  :<C-u>tabonly<CR>
nnoremap <silent> [Tabbed]i  :<C-u>tabs<CR>
nmap [Tabbed]<C-n>  [Tabbed]n
nmap [Tabbed]<C-c>  [Tabbed]c
nmap [Tabbed]<C-o>  [Tabbed]o
nmap [Tabbed]<C-i>  [Tabbed]i
" Move to other tab page.
nnoremap <silent> [Tabbed]j
      \ :execute 'tabnext' 1 + (tabpagenr() + v:count1 - 1) % tabpagenr('$')<CR>
nnoremap <silent> [Window]j
      \ :execute 'tabnext' 1 + (tabpagenr() + v:count1 - 1) % tabpagenr('$')<CR>
nnoremap <silent> [Tabbed]k  :<C-u>tabprevious<CR>
nnoremap <silent> [Window]k  :<C-u>tabprevious<CR>
nnoremap <silent> [Tabbed]K  :<C-u>tabfirst<CR>
nnoremap <silent> [Window][  :<C-u>tabfirst<CR>
nnoremap <silent> [Tabbed]J  :<C-u>tablast<CR>
nnoremap <silent> [Window]]  :<C-u>tablast<CR>
nnoremap <silent> [Tabbed]l
      \ :<C-u>execute 'tabmove' min([tabpagenr() + v:count1 - 1, tabpagenr('$')])<CR>
nnoremap <silent> [Tabbed]h
      \ :<C-u>execute 'tabmove' max([tabpagenr() - v:count1 - 1, 0])<CR>
nnoremap <silent> [Tabbed]L  :<C-u>tabmove<CR>
nnoremap <silent> [Tabbed]H  :<C-u>tabmove 0<CR>
nmap [Tabbed]n  [Tabbed]j
nmap [Tabbed]p  [Tabbed]k
nmap [Tabbed]<C-t>  [Tabbed]j
nmap [Tabbed]<C-l>  [Tabbed]l
nmap [Tabbed]<C-h>  [Tabbed]h

" Change current tab like GNU screen.
" Note that the numbers in {lhs}s are 0-origin.  See also 'tabline'.
for i in range(10)
  execute 'nnoremap <silent>' ('[Tabbed]'.(i))  ((i+1).'gt')
  execute 'nnoremap <silent>' ('[Window]'.(i))  ((i+1).'gt')
endfor
unlet i
"}}}

" Switch the tab page
nnoremap <silent> <C-n> :<C-U>tabnext<CR>
nnoremap <silent> <C-p> :<C-U>tabprevious<CR>

" Move search word and fold open."{{{
nnoremap n  nzz
nnoremap N  Nzz
nnoremap #  #zz
nnoremap g*  g*zz
nnoremap g#  g#zz
"}}}

" Smart <C-f>, <C-b>.
nnoremap <silent> <C-f> z<CR><C-f>zz
nnoremap <silent> <C-b> z-<C-b>zz

" Execute help."{{{
"nnoremap <C-h>  :<C-u>help<Space>
"" Execute help by cursor keyword.
"nnoremap <silent> g<C-h>  :<C-u>help<Space><C-r><C-w><CR>
"}}}

" Nop "{{{
" Disable ZZ. and more "{{{
nnoremap [Nop]  <Nop>
nmap ZZ [Nop]
nmap ZQ [Nop]
nnoremap [Nop]l :<C-u>echo "colorscheme <" . g:colors_name . ">"<CR>
" Todo : [Nop]l -> Display info
nnoremap [Nop]l :<C-u>echo "colorscheme <" . g:colors_name . ">"<CR>

nnoremap [Zop] <Nop>
nmap <C-Z> [Zop]
nnoremap [Zop]l :<C-U>echo "colorscheme <" . g:colors_name . ">"<CR>

" Enter
nnoremap [Enter] <Nop>
nmap <CR> [Enter]

" Ctrl-c
nnoremap [C-c] <Nop>
nmap <C-c> [C-c]
" }}} "}}}

" Redraw.
nnoremap <silent> <C-l>    :<C-u>redraw!<CR>

" Sticky shift in English keyboard."{{{
" Sticky key.
inoremap <expr> ;  <SID>sticky_func()
cnoremap <expr> ;  <SID>sticky_func()
snoremap <expr> ;  <SID>sticky_func()

function! s:sticky_func() "{{{
  let l:sticky_table = {
        \',' : '<', '.' : '>', '/' : '?',
        \'1' : '!', '2' : '"', '3' : '#', '4' : '$', '5' : '%',
        \'6' : '^', '7' : '&', '8' : '*', '9' : '(', '0' : ')', '-' : '_', '=' : '+',
        \';' : ':', '[' : '{', ']' : '}', '`' : '~', "'" : "\"", '\' : '|',
        \}
  let l:special_table = {
        \"\<ESC>" : "\<ESC>", "\<Space>" : ';', "\<CR>" : ";\<CR>"
        \}

  if mode() !~# '^c'
    echo 'Input sticky key: '
  endif
  let l:char = ''

  while l:char == ''
    let l:char = nr2char(getchar())
  endwhile

  if l:char =~ '\l'
    return toupper(l:char)
  elseif has_key(l:sticky_table, l:char)
    return l:sticky_table[l:char]
  elseif has_key(l:special_table, l:char)
    return l:special_table[l:char]
  else
    return ''
  endif
endfunction "}}}
"}}}

" Easy home directory."{{{
function! HomedirOrBackslash()
  if getcmdtype() == ':' && (getcmdline() =~# '^e\%[dit] ' || getcmdline() =~? '^r\%[ead]\?!' || getcmdline() =~? '^cd ')
    return '~/'
  else
    return '\'
  endif
endfunction
cnoremap <expr> <Bslash> HomedirOrBackslash()
"}}}

" macro
nnoremap <C-q> q

"}}}

"---------------------------------------------------------------------------
" Commands:"{{{
"

" Toggle options. "{{{
function! ToggleOption(option_name)
  execute 'setlocal' a:option_name.'!'
  execute 'setlocal' a:option_name.'?'
endfunction  "}}}

" Toggle variables. "{{{
function! ToggleVariable(variable_name)
  if eval(a:variable_name)
    execute 'let' a:variable_name.' = 0'
  else
    execute 'let' a:variable_name.' = 1'
  endif
  echo printf('%s = %s', a:variable_name, eval(a:variable_name))
endfunction  "}}}

" Change current directory."{{{
command! -nargs=? -complete=dir -bang CD  call s:ChangeCurrentDir('<args>', '<bang>')
function! s:ChangeCurrentDir(directory, bang)
  if a:directory == ''
    lcd %:p:h
  else
    execute 'lcd' a:directory
  endif

  if a:bang == ''
    pwd
  endif
endfunction"}}}

" Rename file "{{{
command!
      \ -nargs=1 -bang
      \ -bar -complete=file
      \ Rename saveas<bang> <args>
      \ call delete(expand('#:p'))
"}}}

" Capture ex command "{{{
command!
      \ -nargs=+ -bang
      \ -complete=command
      \ Capture
      \ call s:cmd_capture([<f-args>], <bang>0)

function! C(cmd)
  redir => result
  silent execute a:cmd
  redir END
  return result
endfunction

function! s:cmd_capture(args, banged) "{{{
  new
  silent put =C(join(a:args))
  1,2delete _
endfunction "}}}
"}}}

" Print all mapping "{{{
command!
      \ -nargs=* -complete=mapping
      \ AllMaps
      \ map <args> | map! <args> | lmap <args>
"}}}

" :HighlightWith {filetype} ['a 'b]  XXX: Don't work in some case."{{{
command! -nargs=+ -range=% HighlightWith <line1>,<line2>call s:highlight_with(<q-args>)
" xnoremap [Space]h q:HighlightWith<Space>

function! s:highlight_with(args) range
  if a:firstline == 1 && a:lastline == line('$')
    return
  endif
  let c = get(b:, 'highlight_count', 0)
  let ft = matchstr(a:args, '^\w\+')
  if globpath(&rtp, 'syntax/' . ft . '.vim') == ''
    return
  endif
  unlet! b:current_syntax
  let save_isk= &l:isk  " For scheme.
  execute printf('syntax include @highlightWith%d syntax/%s.vim',
        \              c, ft)
  let &l:isk= save_isk
  execute printf('syntax region highlightWith%d start=/\%%%dl/ end=/\%%%dl$/ '
        \            . 'contains=@highlightWith%d',
        \             c, a:firstline, a:lastline, c)
  let b:highlight_count = c + 1
endfunction"}}}

"}}}

"---------------------------------------------------------------------------
" Functions:"{{{
"

function! SnipMid(str, len, mask) "{{{
  if a:len >= len(a:str)
    return a:str
  elseif a:len <= len(a:mask)
    return a:mask
  endif

  let len_head = (a:len - len(a:mask)) / 2
  let len_tail = a:len - len(a:mask) - len_head

  return (len_head > 0 ? a:str[: len_head - 1] : '') . a:mask . (len_tail > 0 ? a:str[-len_tail :] : '')
endfunction "}}}

" Edit now colorschem file
nnoremap <silent><Space>ec :call <SID>EditNowColorScheme()<CR>
function! s:EditNowColorScheme() "{{{
  let nowcolorscheme = g:colors_name
  let colorlist = map(split(globpath(&runtimepath, 'colors/*.vim'), '\n'),
      \'[fnamemodify(v:val, ":t:r"), fnamemodify(v:val, ":h")]')
  let pos = 0
  for c in colorlist
    if nowcolorscheme  =~# c[0]
      break
    endif
    let pos += 1
  endfor
  " Edit way tab, other tab "{{{
  "if (tabpagenr('$') <= 1 &&  (line('$') <= 1 && col('.') <= 1)) || g:colors_name =~? expand('%:t:r')
  "  edit colorfilepass
  "else
  "  tabedit colorfilepass
  "endif "}}}
  execute 'edit ' colorlist[pos][1] . '/' . colorlist[pos][0] . '.vim'
  unlet! colorlist
  unlet! nowcolorscheme
  unlet! pos
endfunction "}}}

" delete space at end of line (File type is not vim, help)
autocmd BufWritePre,BufWritePre * if ((&ft !~? 'vim') || (&ft !~? 'help')) | call s:RTrim() | endif
function! s:RTrim() "{{{
  let s:cursor = getpos(".")
  %s/\s\+$//e
  call setpos(".", s:cursor)
endfunction "}}}

" }}}

"---------------------------------------------------------------------------
" Platform depends:"{{{
"

if s:iswin
  " For Windows"{{{

  " In Windows, can't find exe, when $PATH isn't contained $VIM.
  if $PATH !~? '\(^\|;\)' . escape($VIM, '\\') . '\(;\|$\)'
    let $PATH = $VIM . ';' . $PATH
  endif

  " Shell settings. "{{{
  " Use NYAOS. "{{{
  "set shell=nyaos.exe
  "set shellcmdflag=-e
  "set shellpipe=\|&\ tee
  "set shellredir=>%s\ 2>&1
  "set shellxquote=\"
  " }}}

  " #- Use CKW with nyaos -# "{{{
  set shell=$VIM/../ckw/ckw.exe
  set shellcmdflag=-e
  set shellpipe=\|&\ tee
  set shellredir=>%s\ 2>&1
  set shellxquote=\"
  " }}}

  " Use bash. "{{{
  "set shell=bash.exe
  "set shellcmdflag=-c
  "set shellpipe=2>&1\|\ tee
  "set shellredir=>%s\ 2>&1
  "set shellxquote=\"
  " }}}
  " }}}

  " Change colorscheme.
  " Don't override colorscheme.
  if !exists('g:colors_name') && !has('gui_running')
    colorscheme darkblue
  endif
  " Disable error messages.
  let g:CSApprox_verbose_level = 0

  " Popup color.
  hi Pmenu ctermbg=8
  hi PmenuSel ctermbg=1
  hi PmenuSbar ctermbg=0
  "}}}
else
  " For Linux"{{{

  if exists('$WINDIR')
    " Cygwin.
    " Use bash.
    set shell=bash
  else
    " Use zsh.
    "set shell=zsh
    set shell=bash
  endif

  " For non GVim.
  if !has('gui_running')
    " Enable 256 color terminal.
    if !exists('$TMUX')
      set t_Co=256
      " Popup color
      hi Pmenu ctermbg=8
      hi PmenuSel ctermbg=1
      hi PmenuSbar ctermbg=0

      " For screen."{{{
      if &term =~ '^screen'
        augroup MyAutoCmd
          " Show filename on screen statusline.
          " But invalid 'another' screen buffer.
          autocmd BufEnter * if $WINDOW != 0 &&  bufname("") !~ "[A-Za-z0-9\]*://"
                \ | silent! exe '!echo -n "kv:%:t\\"' | endif
          " When 'mouse' isn't empty, Vim will freeze. Why?
          autocmd VimLeave * :set mouse=
        augroup END

        " For Vim inside screen.
        set ttymouse=xterm2

        " Split Vim and screen.
        function! ScreenSpiritOpen(cmd)
          call system("screen -X eval split  focus 'screen " . a:cmd ."' focus")
        endfunction
        function! ScreenEval(str)
          let s = substitute(a:str, "[\n]*$", "\n\n", "")
          call writefile(split(s, "\n"), "/tmp/vim-screen", "b")
          call system("screen -X eval focus 'readreg p /tmp/vim-screen' 'paste p' focus")
        endfunction

        command! -nargs=1 Screen call ScreenSpiritOpen("<args>")

        " Pseudo :suspend with automtic cd.
        " Assumption: Use GNU screen.
        " Assumption: There is a window with the title "another".
        noremap <silent> <C-z>  :<C-u>call PseudoSuspendWithAutomaticCD()<CR>

        if !exists('g:gnu_screen_availablep')
          " Check the existence of $WINDOW to avoid using GNU screen in Vim on
          " a remote machine (for example, "screen -t remote ssh example.com").
          let g:gnu_screen_availablep = len($WINDOW) != 0
        endif
        function! PseudoSuspendWithAutomaticCD()
          if g:gnu_screen_availablep
            " \015 = <C-m>
            " To avoid adding the cd script into the command-line history,
            " there are extra leading whitespaces in the cd script.
            silent execute '!screen -X eval'
                  \         '''select another'''
                  \         '''stuff " cd \"'.getcwd().'\"  \#\#,vim-auto-cd\015"'''
            redraw!
            let g:gnu_screen_availablep = (v:shell_error == 0)
          endif

          if !g:gnu_screen_availablep
            suspend
          endif
        endfunction
      endif

      " For prevent bug.
      autocmd MyAutoCmd VimLeave * set term=screen
      "}}}
    endif

    if has('gui')
      " Use CSApprox.vim

      " Disable error messages.
      let g:CSApprox_verbose_level = 0
    endif
  endif
  "}}}
endif

"}}}

"---------------------------------------------------------------------------
" Others:"{{{
"

" Enable mouse support.
set mouse=a

" If true Vim master, use English help file.
set helplang& helplang=ja,en

" Default home directory.
let g:home = getcwd()
let t:cwd = getcwd()

" Each tab has current directory."{{{
command! -bar -complete=dir -nargs=?
      \   CD
      \   TabpageCD <args>
command! -bar -complete=dir -nargs=?
      \   TabpageCD
      \   execute 'cd' fnameescape(expand(<q-args>))
      \   | let t:cwd = getcwd()

autocmd TabEnter *
      \   if exists('t:cwd') && !isdirectory(t:cwd)
      \ |     unlet t:cwd
      \ | endif
    \ | if !exists('t:cwd')
      \ |   let t:cwd = getcwd()
      \ | endif
    \ | execute 'cd' fnameescape(expand(t:cwd))

" Exchange ':cd' to ':TabpageCD'.
cnoreabbrev <expr> cd (getcmdtype() == ':' && getcmdline() ==# 'cd') ? 'TabpageCD' : 'cd'
"}}}

" Verbose "{{{
"set verbose=15
" Make recoding directory "{{{
let s:verbosedir = g:vim_info_dir . '/others/.verbose'
if !isdirectory(s:verbosedir)
  call mkdir(s:verbosedir, 'p')
endif
let $VERBOSE=s:verbosedir
set verbosefile=$VERBOSE/verboseinfo.txt "}}}
unlet s:verbosedir "}}}

" #- viminfo -# "{{{
" Set place for save infofile
let s:infodir = g:vim_info_dir . '/info'
if !isdirectory(s:infodir)
  call mkdir(s:infodir, 'p')
endif
let $INFO=s:infodir
unlet! s:infodir
"set viminfo=<50,'10,h,r/a,n$INFO/.viminfo
set viminfo&
set viminfo='50,h,f1,n$INFO/.viminfo
" Don't make viminfo
"set viminfo=
" }}}
"}}}

"---------------------------------------------------------------------------
" #- Misc. -# "{{{
"
"  (^_^)
" Auto make directory "{{{
"augroup vimrc-auto-mkdir "{{{
"  autocmd!
"  autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
"  function! s:auto_mkdir(dir, force) "{{{
"    if !isdirectory(a:dir) && (a:force ||
"          \ input(printf('"%s" does not exist. Create? [y/N]', a:dir)) =~? '^y\%[es]$')
"      call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
"    endif
"  endfunction "}}}
"augroup END "}}}
"}}}
" Fold text to =, - "{{{
"setlocal foldmethod=expr foldexpr=MyHelpFold(v:lnum)
"setlocal foldtext=MyHelpFoldText()
function! MyHelpFold(lnum) "{{{
  let line = getline(a:lnum)
  let next = getline(a:lnum + 1)
  let prev = getline(a:lnum - 1)
  if line =~ '^=\{78}$'
    return 1
  elseif next =~ '^=\{78}$'
    return '<1'
  elseif line =~ '^-\{78}$'
    return 2
  elseif next =~ '^-\{78}$'
    return '<2'
" elseif line =~ '^\S.\+\*$' && prev !~ '\*$' && prev !~ '^\(.\)\1\+$'
" return 3
" elseif next =~ '^\S.\+\*$' && line !~ '\*$'
" return '<3'
  endif
  return '='
endfunction
" }}}
function! MyHelpFoldText() "{{{
  let base = '+-' . v:folddashes . printf('%3d', v:foldend - v:foldstart) . ' lines : '
  let line = getline(v:foldstart)
  if line =~ '^\(.\)\1\+$'
    let line = getline(v:foldstart + 1)
  endif
  if line =~ '\t\|\s\{4,}'
    let [head, tail] = matchlist(line, '^\(.\{-}\)\%(\t\|\s\{4,}\)\s*\(.*\)$')[1 : 2]
    let line = head . repeat(' ', 78 - strdisplaywidth(base . head . tail)) . tail
  endif
  return base . line
endfunction

" }}}
"}}}
" Junk File "{{{
" #########################################################################
"  Open junk file. via.http://vim-users.jp/2010/11/hack181/
" #########################################################################
command! -nargs=0 JunkFile call s:open_junk_file()
function! s:open_junk_file()
  let l:junk_dir = g:vim_dir . '/junk'. strftime('/%Y')
  if !isdirectory(l:junk_dir)
    call mkdir(l:junk_dir, 'p')
  endif

  let l:filename = input('Junk Code: ', l:junk_dir.strftime('/%Y-%m-%d-%H%M%S.'))
  if l:filename != ''
    execute 'split ' . l:filename
  endif
endfunction
"}}}
" ColorRoller "{{{
let ColorRoller = {}
let ColorRoller.colors = [
      \ 'cu',
      \ 'YacEv',
      \ 'Opposer',
      \ 'Layven',
      \ 'angel',
      \ 'ImPgRw',
      \ 'Cugfr',
      \ 'ZycUs',
      \ 'GxeiM',
      \ 'Moufr02',
      \ 'bonar',
      \ 'joker',
      \ ]

function! ColorRoller.change()
  let color = get(self.colors, 0)
  silent exe "colorscheme " . color
  redraw
  echo self.colors
endfunction

function! ColorRoller.roll()
  let item = remove(self.colors, 0)
  call insert(self.colors, item, len(self.colors))
  call self.change()
endfunction

function! ColorRoller.unroll()
  let item = remove(self.colors, -1)
  call insert(self.colors, item, 0)
  call self.change()
endfunction

nnoremap <silent> + :call ColorRoller.roll()<CR>
nnoremap <silent> - :call ColorRoller.unroll()<CR>
"}}}
"}}}

set secure

"---------------------------------------------------------------------------
" End: "{{{1
" vim: fen:fdm=marker
" vim: filetype=vim
